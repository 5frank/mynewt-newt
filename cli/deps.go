package cli

import (
	"os"
	"path/filepath"
	"strings"
	"time"
)

type DepTracker struct {
	// Most recent .o modification time.
	MostRecent time.Time

	compiler *Compiler
}

func NewDepTracker(c *Compiler) DepTracker {
	tracker := DepTracker{
		MostRecent: time.Unix(0, 0),
		compiler:   c,
	}

	return tracker
}

// Parses a dependency (.d) file generated by gcc.  On success, the returned
// string array is populated with the dependency filenames.  This function
// expects the first line of a dependency file to have the following format:
//
// <file>.d: <file>.c a.h b.h c.h \
//  d.h e.h f.h
//
// This function ignores all lines except for the first.
func ParseDepsFile(filename string) ([]string, error) {
	lines, err := ReadLines(filename)
	if err != nil {
		return nil, err
	}

	if len(lines) == 0 {
		return []string{}, nil
	}

	// Assume only the first line is important.
	tokens := strings.Fields(lines[0])
	if len(tokens) == 0 {
		return nil, NewNewtError("Invalid Makefile dependency file; first " +
			"line is blank")
	}

	dFileTok := tokens[0]
	if dFileTok[len(dFileTok)-1:] != ":" {
		return nil, NewNewtError("Invalid Makefile dependency file; first " +
			"line missing ':'")
	}

	return tokens[1:], nil
}

// Determines if the specified C or assembly file needs to be built.  If the
// source file or any of its dependencies has been modified more recently than
// the destination object file, a build is required.
func (tracker *DepTracker) CompileRequired(srcFile string) (bool, error) {
	wd, _ := os.Getwd()
	objDir := wd + "/obj/" + tracker.compiler.TargetName + "/"

	objFile := objDir + strings.TrimSuffix(srcFile, filepath.Ext(srcFile)) +
		".o"
	depFile := objDir + strings.TrimSuffix(srcFile, filepath.Ext(srcFile)) +
		".d"

	srcModTime, err := FileModificationTime(srcFile)
	if err != nil {
		return false, err
	}

	objModTime, err := FileModificationTime(objFile)
	if err != nil {
		return false, err
	}

	// If the object doesn't exist or is older than the source file, a build is
	// required; no need to check dependencies.
	if srcModTime.After(objModTime) {
		tracker.MostRecent = time.Now()
		return true, nil
	}

	// Cache the object modification time if it is more recent than the current
	// one.
	if objModTime.After(tracker.MostRecent) {
		tracker.MostRecent = objModTime
	}

	// Determine if the dependency (.d) file needs to be generated.  If it
	// doesn't exist or is older than the source file, it is out of date and
	// needs to be created.
	depModTime, err := FileModificationTime(depFile)
	if err != nil {
		return false, err
	}

	if srcModTime.After(depModTime) {
		err := tracker.compiler.GenDepsForFile(srcFile)
		if err != nil {
			return false, err
		}
	}

	// Extract the dependency filenames from the dependency file.
	deps, err := ParseDepsFile(depFile)
	if err != nil {
		return false, err
	}

	// Check if any dependencies are newer than the destination object file.
	for _, dep := range deps {
		depModTime, err := FileModificationTime(dep)
		if err != nil {
			return false, err
		}
		if depModTime.After(objModTime) {
			tracker.MostRecent = time.Now()
			return true, nil
		}
	}

	return false, nil
}

// Determines if the specified static library needs to be rearchived.
// Archiving is necessary if the library does not exist or has an older
// modification time than any source object file.
func (tracker *DepTracker) ArchiveRequired(aFile string) (bool, error) {
	aModTime, err := FileModificationTime(aFile)
	if err != nil {
		return false, err
	}

	return tracker.MostRecent.After(aModTime), nil
}

// Determines if the specified elf file needs to be linked.  Linking is
// necessary if the elf file does not exist or has an older modification time
// than any source object or library file.
func LinkRequired(dest string, objs []string) (bool, error) {
	dstModTime, err := FileModificationTime(dest)
	if err != nil {
		return false, err
	}

	for _, obj := range objs {
		objModTime, err := FileModificationTime(obj)
		if err != nil {
			return false, err
		}

		if objModTime.After(dstModTime) {
			return true, nil
		}
	}

	return false, nil
}
